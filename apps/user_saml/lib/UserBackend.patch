36a37
> use OCP\Authentication\IProvideUserSecretBackend;
40c41
< class UserBackend implements IApacheBackend, UserInterface, IUserBackend {
---
> class UserBackend implements IApacheBackend, UserInterface, IUserBackend, IProvideUserSecretBackend {
144a146,152
> 			// If we use per-user encryption the keys must be initialized first
> 			$userSecret = $this->getUserSecret($uid, $attributes);
> 			if ($userSecret !== null) {
> 				$this->updateUserSecretHash($uid, $userSecret);
> 				// Emit a post login action to initialize the encryption module with the user secret provided by the idp.
> 				\OC_Hook::emit('OC_User', 'post_login', ['run' => true, 'uid' => $uid, 'password' => $userSecret, 'isTokenLogin' => false]);
> 			}
150a159,204
> 	private function getUserSecretHash($uid) {
> 		$qb = $this->db->getQueryBuilder();
> 		$qb->select('token')
>  		    ->from('user_saml_auth_token')
>  		    ->where($qb->expr()->eq('uid', $qb->createNamedParameter($uid)))
>  		    ->where($qb->expr()->eq('name', $qb->createNamedParameter('sso_secret_hash')))
>  		    ->setMaxResults(10);
> 		$result = $qb->execute();
> 		$data = $result->fetchAll();
> 		$result->closeCursor();
> 		return $data;
> 	}
>  
> 	private function checkUserSecretHash($uid, $userSecret) {
> 		$data = $this->getUserSecretHash($uid);
> 		foreach($data as $row) {
> 			$storedHash = $row['token'];
> 			if (\OC::$server->getHasher()->verify($userSecret, $storedHash, $newHash)) {
> 				if (!empty($newHash)) {
> 					$this->updateUserSecretHash($uid, $userSecret, true);
> 				}
> 				return true;
> 			}
>  		}
> 		return false;
> 	}
> 
> 	private function updateUserSecretHash($uid, $userSecret, $exists = false) {
> 		$qb = $this->db->getQueryBuilder();
> 		$hash = \OC::$server->getHasher()->hash($userSecret);
> 		if ($exists || count($this->getUserSecretHash($uid)) > 0) {
> 			$qb->update('user_saml_auth_token')
> 			  ->set('token', $qb->createNamedParameter($hash))
> 			  ->where($qb->expr()->eq('uid', $qb->createNamedParameter($uid)))
>  			  ->where($qb->expr()->eq('name', $qb->createNamedParameter('sso_secret_hash')));
> 		} else {
> 			$qb->insert('user_saml_auth_token')
> 			  ->values([
> 			    'uid' => $qb->createNamedParameter($uid),
> 			    'token' => $qb->createNamedParameter($hash),
>  			    'name' => $qb->createNamedParameter('sso_secret_hash'),
> 			  ]);
> 		}
> 		return $qb->execute();
>  	}
> 
194a249,252
> 	 *
> 	 * By default user_saml tokens are passwordless and this function
> 	 * is unused. It is only called if we have tokens with passwords,
> 	 * which happens if we have SSO provided user secrets.
197,211c255,257
< 		/* @var $qb IQueryBuilder */
< 		$qb = $this->db->getQueryBuilder();
< 		$qb->select('token')
< 			->from('user_saml_auth_token')
< 			->where($qb->expr()->eq('uid', $qb->createNamedParameter($uid)))
< 			->setMaxResults(1000);
< 		$result = $qb->execute();
< 		$data = $result->fetchAll();
< 		$result->closeCursor();
< 
< 		foreach($data as $passwords) {
< 			if(password_verify($password, $passwords['token'])) {
< 				return $uid;
< 			}
< 		}
---
> 	    if ($this->checkUserSecretHash($uid, $password)) {
> 			return $uid;
>  		}
496a543,544
> 			$uid = $this->userData->testEncodedObjectGUID($uid);
> 
502a551,560
> 	/**
> 	 * Optionally returns a stable per-user secret. This secret is for
> 	 * instance used to secure file encryption keys.
> 	 * @return string|null
> 	 * @since 23.0.0
> 	 */
> 	public function getCurrentUserSecret(): ?string {
> 		$samlData = $this->session->get('user_saml.samlUserData');
> 		return $this->getUserSecret($this->getCurrentUserId(), $samlData);
> 	}
600a659,673
> 	private function getUserSecret($uid, array $attributes) {
> 		try {
> 			$userSecret = $this->getAttributeValue('saml-attribute-mapping-user_secret_mapping', $attributes);
> 			if ($userSecret === '') {
> 				$this->logger->debug('Got no user_secret from idp', ['app' => 'user_saml']);
> 			} else {
> 				$this->logger->debug('Got user_secret from idp', ['app' => 'user_saml']);
> 				return $userSecret;
> 			}
> 		} catch (\InvalidArgumentException $e) {
> 			$this->logger->debug('No user_secret mapping configured', ['app' => 'user_saml']);
> 		}
> 		return null;
> 	}
> 
638c711
< 			$currentEmail = (string)(method_exists($user, 'getSystemEMailAddress') ? $user->getSystemEMailAddress() : $user->getEMailAddress());
---
> 			$currentEmail = (string)$user->getEMailAddress();
673a747,753
> 				}
> 			}
> 
> 			$userSecret = $this->getUserSecret($uid, $attributes);
> 			if ($userSecret !== null) {
> 				if (!$this->checkUserSecretHash($uid, $userSecret)) {
> 					$this->updateUserSecretHash($uid, $userSecret);
